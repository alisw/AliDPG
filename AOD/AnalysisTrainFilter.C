//===================== ANALYSIS TRAIN =========================================
// To use: copy this macro to your work directory, modify the global part to match
// your needs, then run root.
//    root[0] .L AnalysisTrain.C
// Grid full mode as below (other modes: test, offline, submit, terminate)
//    root[1] AnalysisTrainNew("grid", "full")
// CAF mode (requires root v5-23-02 + aliroot v4-16-Rev08)
//    root[2] AnalysisTrainNew("proof")
// Local mode requires AliESds.root or AliAOD.root in ./data directory
//    root[3] AnalysisTrainNew("local")
// In proof and grid modes, a token is needed and sourcing the produced environment file.
//
// If 'saveTrain' flag is set, the train will generate a directory name and run
// in this directory. A configuration file 'ConfigTrain.C' will be generated. 
// One can replay at any time the train via:
//    root[1] AnalysisTrainNew(ana_mode, plugin_mode, "train_default_<date>/ConfigTrain.C")

/*****************************************
When running in local mode, you need
to write a file containing, for example

export ALIEN_JDL_LPMINTERACTIONTYPE=pp
export ALIEN_JDL_LPMANCHORYEAR=2015
export ALIEN_JDL_LPMPRODUCTIONTAG=LHC15n
export ALIEN_JDL_LPMRUNNUMBER=244628

then source it
******************************************/

TString     train_tag          = "_p-p_";  // Train special tag appended to visible name. ("data", "sim", "pp", "highmult", ...)
Int_t       iCollision         = 1;        // 0=pp, 1=Pb-Pb
Int_t       run_flag           = 1100;     // 1000 year 2010 LHCbcde cuts, 1100 year 2011 pp cuts, 1500 year 2015
TString     periodName         = "LHC12a"; // Set the period name, not only for testing, but also passed by a couple of tasks as args
Int_t       run_number         = 0;        // For tasks arguments, CDB connect
Bool_t      localRunning       = kFALSE;   // Missing environment vars will cause a crash; change it to kTRUE if running locally w/o env vars
Bool_t      isMuonCaloPass     = kTRUE;    // setting this to kTRUE will disable some not needed analysis tasks for a muon_calo pass

//TString     root_version       = "v5-34-30-alice5-1";  // *CHANGE ME IF MORE RECENT IN GRID*
//TString     aliroot_version    = "v5-08-13e-1";        // *CHANGE ME IF MORE RECENT IN GRID*
TString     aliphysics_version = "v5-09-09-01-1";     // *CHANGE ME IF MORE RECENT IN GRID*

TString     train_name = "FILTERpass2"; // local folder name;
TString     visible_name;
// Add train composition and other comments
TString     job_comment;
TString     job_tag;


//==============================================================================

// ### Settings that make sense in PROOF only
//==============================================================================
TString     proof_cluster      = "alice-caf.cern.ch";
Bool_t      useAFPAR           = kFALSE;  // use AF special par file
TString     AFversion          = "AF-v4-17";
// Change CAF dataset here
TString     proof_dataset      = "/COMMON/COMMON/LHC09a4_run8100X#/esdTree";
TString     proof_outdir       = "";

// ### Settings that make sense when using the Alien plugin
//==============================================================================
Int_t       runOnData          = 1;       // Set to 1 if processing real data
Bool_t      usePLUGIN          = kTRUE;   // do not change
Bool_t      useProductionMode  = kTRUE;   // use the plugin in production mode
// Usage of par files ONLY in grid mode and ONLY if the code is not available
// in the deployed AliRoot versions. Par file search path: local dir, if not there $ALICE_ROOT.
// To refresh par files, remove the ones in the workdir, then do "make <target.par>" in 
// AliRoot.
Bool_t      usePAR             = kFALSE;  // use par files for extra libs
Bool_t      useCPAR            = kFALSE;  // use par files for common libs
// Change production base directory here (test mode)
TString     alien_datadir      = "/alice/data/2015/LHC15o";
// Work directory in GRID (DON'T CHANGE)
TString     grid_workdir       = "/alice/cern.ch/user/a/alidaq/AOD/AOD$2";
// Data pattern - change as needed for test mode
TString     data_pattern       = "/pass1/*ESDs.root";
Int_t       run_numbers[10]    = {244628}; // Set the run range, for testing
//Int_t       run_range[2]       =  {114786, 114949};  // LHC09a7   *CHANGE ME*
// AliEn output directory. If blank will become output_<train_name>
               // Output directory (DON'T CHANGE)
TString     alien_outdir       = "$1/AOD$2";
               // Input collection (production mode)
TString     data_collection    = "$1/qa1.xml";
// Output folder to write delta AOD's. Considered if not null.
TString     outputSingleFolder = "";
//TString     outputSingleFolder = "deltas";
// Number of files merged in a chunk
Int_t       maxMergeFiles      = 30;
// Number of test files
Int_t       nTestFiles         = 1;
// Files that should not be merged
TString     mergeExclude       = "AliAOD.root AliAOD.VertexingHF.root FilterEvents_Trees.root AliAOD.Jets.root AliAOD.Muons.root";
TString     mergeDirName       = "AOD$2";
// Make replicas on the storages below
TString     outputStorages      = "disk=4";
Int_t       outputReplicas      = 3;
// Number of runs per master job
Int_t       nRunsPerMaster     = 10;
// Maximum number of files per job (gives size of AOD)
Int_t       nFilesPerJob       = 10;
// Int_t       nFilesPerJob       = 1; (AOD->delta AOD production case)
// ### Settings that make sense only for local analysis
//==============================================================================
// Change local xml dataset for local interactive analysis
TString     local_xmldataset   = "";
const char *cdbPath = "raw://";

enum ECOLLISIONSYSTEM_t
{
    kpp,
    kPbPb,
    kpA,
    kNSystem
};

const Char_t* CollisionSystem[kNSystem] =
{
    "pp",
    "PbPb",
    "pA",
};

void ProcessEnvironment();
void PrintSettings();


// ### Other flags to steer the analysis
//==============================================================================
Bool_t      doCDBconnect        = kTRUE;
Bool_t      usePhysicsSelection = kTRUE;  // use physics selection
Bool_t      useTender           = kFALSE; // use tender wagon
Bool_t      useCentrality       = kFALSE; // centrality delta AOD
Bool_t      useV0tender         = kFALSE; // use V0 correction in tender
Bool_t      useMergeViaJDL      = kTRUE;  // merge via JDL
Bool_t      useFastReadOption   = kFALSE; // use xrootd tweaks
Bool_t      useOverwriteMode    = kTRUE;  // overwrite existing collections
Bool_t      useDATE             = kFALSE; // use date in train name
Bool_t      useDBG              = kFALSE; // activate debugging
Bool_t      useMC               = kFALSE; // use MC info
Bool_t      useTAGS             = kFALSE; // use ESD tags for selection
Bool_t      useKFILTER          = kFALSE; // use Kinematics filter
Bool_t      useTR               = kFALSE; // use track references
Bool_t      useCORRFW           = kFALSE; // do not change
Bool_t      useAODTAGS          = kFALSE; // use AOD tags
Bool_t      saveTrain           = kTRUE;  // save train configuration as: 
Bool_t      saveCanvases        = kFALSE; // save canvases created in Terminate
Bool_t      saveProofToAlien    = kFALSE; // save proof outputs in AliEn

// ### Analysis modules to be included. Some may not be yet fully implemented.
//==============================================================================
Int_t       iAODanalysis        = 0;      // Analysis on input AOD's
Int_t       iAODhandler         = 1;      // Analysis produces an AOD or dAOD's
Int_t       iESDfilter          = 1;      // ESD to AOD filter (barrel + muon tracks)
Int_t       iESDfilterReVtx     = -1;     // Request revertexing in ESD filtering
Int_t       iMUONcopyAOD        = 1;      // Task that copies only muon events in a separate AOD (PWG3)
Int_t       iMUONRefit          = 1;      // Refit ESD muon tracks before producing AODs
Int_t       iJETAN              = 0;      // ? Jet analysis (PWG4)
Int_t       iJETANdelta         = 0;      // ? Jet delta AODs
Int_t       iPWG4partcorr       = 0;      // Gamma-hadron correlations task (PWG4)
Int_t       iPWGGAgammaconv     = 1;      // Gamma conversion analysis (PWG4)
Int_t       iPWG4omega3pi       = 0;      // Omega to 3 pi analysis (PWG4)
Int_t       iPWGHFvertexing     = 1;      // Vertexing HF task (PWG3)
Int_t       iPWG3hfe            = 0;      // Electrons analysis (PWG3)
Int_t       iPWGDQJPSIfilter    = 0;      // JPSI filtering (PWG3)
Int_t       iPWGDQJPSI          = 0;      // JPSI analysis (PWG3)
Int_t       iPWGHFd2h           = 0;      // D0->2 hadrons (PWG3) -- ALPHY-63 ==> disabled
Int_t       iPWGMuonTrain       = 0;      // Muon analysis train
Int_t       iPWG2forward        = 0;
Int_t       iPWG2femto          = 0;      // Femtoscopy task (PWG2)
Int_t       iPWG2spectra        = 0;      // Spectra tasks (PWG2
Int_t       iPWG2protons        = 0;      // Proton-antiproton analysis
Int_t       iPWG2checkcascade   = 0;      // Check cascades task
Int_t       iPWG2perfcascade    = 0;      // Check performance cascade
Int_t       iPWG2checkv0        = 0;      // Check V0 task
Int_t       iPWG2strange        = 0;      // Strangeness task
Int_t       iPWG2central        = 0;      // Anisothropy in central collisions
Int_t       iPWG2flow           = 0;      // Flow analysis tasks (PWG2)
Int_t       iPWG2res            = 0;      // Resonances task (PWG2)
Int_t       iPWG2rsneff         = 0;      // Resonances efficiency
Int_t       iPWG2kink           = 0;      // Kink analysis tasks (PWG2)
Int_t       iPWG2kinkESDMC      = 0;      // Kink ESD-MC comparison (PWG2)
Int_t       iPWG2kinkLSKstar    = 0;      // Kink like-sign K* (PWG2)
Int_t       iPWG2kinkLSL1520    = 0;      // Kink like-sign L1520 (PWG2)
Int_t       iPWG2kinkLSPhi      = 0;      // Kink like-sign Phi (PWG2)
Int_t       iPWG2kinkKstarESD   = 0;      // Kink Kstar ESD (PWG2)
Int_t       iPWG2kinkKstarMC    = 0;      // Kink Kstar MC (PWG2)
Int_t       iPWG2kinkL1520ESD   = 0;      // Kink L1520 ESD (PWG2)
Int_t       iPWG2kinkL1520MC    = 0;      // Kink L1520 MC (PWG2)
Int_t       iPWG2kinkPhiESD     = 0;      // Kink resonances Phi ESD (PWG2)
Int_t       iPWG2kinkPhiMC      = 0;      // Kink resonances Phi MC (PWG2)
Int_t       iPWG2evchar         = 0;      // Event characteristics (PWG2)
Int_t       iPWG2unicor         = 0;      // Unicor analysis (PWG2)
Int_t       iPWGPP              = 1;      // high pt filter task
Int_t       iPWGLFForward       = 1;      // Forward mult task (PWGLF)
Bool_t      doPIDResponse       = 1;
Bool_t      doPIDqa             = 1;      //new

// ### Configuration macros used for each module
//==============================================================================
TString     configPWG2femto    = "$ALICE_ROOT/PWG2/FEMTOSCOPY/macros/Train/Train3/ConfigFemtoAnalysis.C";
//  TString     configPWG3d2h      = "$ALICE_ROOT/PWGHF/vertexingHF/ConfigVertexingHF_Pb_Cent2080.C";
//  TString     configPWG3d2h      = "$ALICE_ROOT/PWGHF/vertexingHF/ConfigVertexingHF_highmult.C";
//  TString     configPWG3d2h      = "$ALICE_PHYSICS/PWGHF/vertexingHF/ConfigVertexingHF.C";
//  TString     configPWG3d2h      = "$ALICE_ROOT/PWGHF/vertexingHF/ConfigVertexingHF_Pb_AllCent_NoLS_PIDLc.C";
// Temporaries.
TString anaPars = "";
TString anaLibs = "";
// Function signatures
class AliAnalysisAlien;

//______________________________________________________________________________
void UpdateFlags()
{
  // Update flags according to type of pass
  if ( isMuonCaloPass )
  {
    // disable the analysis we know for sure can not work or are meaningless
    // for a muon_calo pass
    doCDBconnect       = kFALSE;
    iPWGHFvertexing    = 0; 
    iPWGHFd2h          = 0; 
    iPWGPP             = 0; 
    iPWGLFForward      = 0; 
    iPWGGAgammaconv    = 0; 
    doPIDResponse      = 0; 
    doPIDqa            = 0; 
  }
}

//______________________________________________________________________________
void AnalysisTrainFilter(const char *analysis_mode="grid", 
                      const char *plugin_mode="full",
                      const char *config_file="")
{
  ProcessEnvironment();
  
  UpdateFlags();
  
  PrintSettings();

  //==================   TRAIN NAME   ============================================
  // Name in train page (DON'T CHANGE)
  visible_name       = Form("FILTER%s$2_$3", train_tag.Data()); //# FIXED #
  // Add train composition and other comments
  job_comment        = "Standard AODs + deltas";
  job_tag            = Form("%s: %s", visible_name.Data(), job_comment.Data());

// Main analysis train macro. If a configuration file is provided, all parameters
// are taken from there but may be altered by CheckModuleFlags.
   if (strlen(config_file) && !LoadConfig(config_file)) return;
   TString smode(analysis_mode);
   smode.ToUpper();
   TString spmode(plugin_mode);
   spmode.ToLower();
   if (spmode == "test") useProductionMode = kFALSE;
   // Check compatibility of selected modules
   CheckModuleFlags(smode);
   if (saveTrain)              WriteConfig();

   printf("==================================================================\n");
   printf("===========    RUNNING ANALYSIS TRAIN %s IN %s MODE   ==========\n", train_name.Data(),smode.Data());
   printf("==================================================================\n");
   printf("=  Configuring analysis train for:                               =\n");
   if (iAODanalysis) printf("=  AOD analysis                                                  =\n");
   else              printf("=  ESD analysis                                                  =\n");
   if (usePhysicsSelection)   printf("=  Physics selection                                                =\n");
   if (useTender)    printf("=  TENDER                                                        =\n");
   if (iESDfilter)
   {
     printf("=  ESD filter                                                    =\n");
     if (iESDfilterReVtx>=0)  printf("=  ESD event revertexed before filterering, algo %2d              =\n",iESDfilterReVtx);
   }
   if (iMUONcopyAOD) printf("=  MUON copy AOD                                                 =\n");
   if (iJETAN)       printf("=  Jet analysis                                                  =\n");
   if (iJETANdelta)  printf("=     Jet delta AODs                                             =\n");
   if (iPWG2spectra)
   {
      printf("=  PWG2 SPECTRA tasks :                                          =\n");
      if (iPWG2protons)      printf("=     PWG2 proton-antiproton                                     =\n");
      if (iPWG2checkcascade) printf("=     PWG2 check cascades                                        =\n");
      if (iPWG2perfcascade)  printf("=     PWG2 performance cascades                                  =\n");
      if (iPWG2checkv0)      printf("=     PWG2 check V0                                              =\n");
      if (iPWG2strange)      printf("=     PWG2 strangeness                                           =\n");
      if (iPWG2central)      printf("=     PWG2 central                                               =\n");
   }   
   if (iPWG2femto)
   {
      printf("=  PWG2 femtoscopy                                               =\n");
      printf("   +++ configured by: %s\n", configPWG2femto.Data());
   }   
   if (iPWG2flow)    printf("=  PWG2 flow                                                     =\n");
   if (iPWG2res)     printf("=  PWG2 resonances                                               =\n");
      if (iPWG2rsneff)    printf("=     PWG2 resonances efficiency                                    =\n");
   if (iPWG2kink)
   {
      printf("=  PWG2 kink analysis tasks:                                     =\n");
      if (iPWG2kinkESDMC)    printf("=     PWG2 ESD-MC kinks                                          =\n");
      if (iPWG2kinkLSKstar)  printf("=     PWG2 kink like-sign analysis K*                            =\n");
      if (iPWG2kinkLSL1520)  printf("=     PWG2 kink like-sign analysis L1520                         =\n");
      if (iPWG2kinkLSPhi)    printf("=     PWG2 kink like-sign analysis Phi                           =\n");
      if (iPWG2kinkKstarESD) printf("=     PWG2 kink Kstar ESD analysis                               =\n");
      if (iPWG2kinkKstarMC)  printf("=     PWG2 kink Kstar MC analysis                                =\n");
      if (iPWG2kinkL1520ESD) printf("=     PWG2 kink L1520 ESD analysis                               =\n");
      if (iPWG2kinkL1520MC)  printf("=     PWG2 kink L1520 MC analysis                                =\n");
      if (iPWG2kinkPhiESD) printf("=     PWG2 kink Phi ESD analysis                                 =\n");
      if (iPWG2kinkPhiMC)  printf("=     PWG2 kink Phi MC analysis                                  =\n");
  }   
   if (iPWG2evchar)    printf("=  PWG2 event characteristics                                    =\n");
   if (iPWG2unicor)    printf("=  PWG2 Unicor analysis                                          =\n");
   if (iPWGLFForward)   printf("=  PWG2 forward: sharing, density, bkg. correction, dNdEta       =\n");
   if (iPWGHFvertexing) printf("=  PWG3 vertexing                                                =\n");
   if (iPWG3hfe)       printf("=  PWG3 electrons                                                =\n");
   if (iPWGDQJPSIfilter) printf("=  PWG3 j/psi filter                                             =\n");
   if (iPWGDQJPSI)      printf("=  PWG3 j/psi                                                    =\n");
   if (iPWGHFd2h) {
      printf("=  PWG3 D0->2 hadrons QA                                     =\n");
   }         
   if (iPWGMuonTrain) printf("=  PWG3 muon train                                               =\n");
   if (iPWG4partcorr)  printf("=  PWG4 gamma-hadron, pi0 and gamma-jet correlations             =\n");
   if (iPWGGAgammaconv) printf("=  PWG4 gamma conversion                                         =\n");
   if (iPWG4omega3pi)  printf("=  PWG4 omega to 3 pions                                         =\n");
   printf("==================================================================\n");
   printf(":: use physics selection: %d\n", (UInt_t)usePhysicsSelection);
   printf(":: use centrality:        %d\n", (UInt_t)useCentrality);
   printf(":: use xrootd tweaks:     %d\n", (UInt_t)useFastReadOption);
   printf(":: use overwrite xml    : %d\n", (UInt_t)useOverwriteMode);
   printf(":: use merge via JDL:     %d\n", (UInt_t)useMergeViaJDL);
   printf(":: use MC truth:          %d\n", (UInt_t)useMC);
   printf(":: use KINE filter:       %d\n", (UInt_t)useKFILTER);
   printf(":: use track references:  %d\n", (UInt_t)useTR);
   printf(":: use tags:              %d\n", (UInt_t)useTAGS);
   printf(":: use AOD tags:          %d\n", (UInt_t)useAODTAGS);
   printf(":: use debugging:         %d\n", (UInt_t)useDBG);
   printf(":: use PAR files:         %d\n", (UInt_t)usePAR);
   printf(":: use AliEn plugin:      %d\n", (UInt_t)usePLUGIN);

   //==========================================================================
   // Connect to back-end system
//   if (!Connect(smode)) {
//      ::Error("AnalysisTrain", "Could not connect to %s back-end", analysis_mode);
//      return;
//   }   

   // Load common libraries and set include path
   if (!LoadCommonLibraries(smode))
   {
      ::Error("AnalysisTrain", "Could not load common libraries");
      return;
   }
    
   // Make the analysis manager and connect event handlers
   AliAnalysisManager *mgr  = new AliAnalysisManager("Analysis Train", "Production train");
   if (saveProofToAlien) mgr->SetSpecialOutputLocation(proof_outdir);
   if (!strcmp(plugin_mode, "test")) mgr->SetNSysInfo(100);
   // Load analysis specific libraries
   if (!LoadAnalysisLibraries(smode))
   {
      ::Error("AnalysisTrain", "Could not load analysis libraries");
      return;
   }   

   // Create input handler (input container created automatically)
   if (iAODanalysis)
   {
   // AOD input handler
      AliAODInputHandler *aodH = new AliAODInputHandler();
      if (iPWGHFd2h) aodH->AddFriend("AliAOD.VertexingHF.root");
      mgr->SetInputEventHandler(aodH);
   } 
   else
   {
   // ESD input handler
      AliESDInputHandler *esdHandler = new AliESDInputHandler();
      if (useTAGS) esdHandler->SetReadTags();
      mgr->SetInputEventHandler(esdHandler);       
   }
   // Monte Carlo handler
   if (useMC && !iAODanalysis)
   {
      AliMCEventHandler* mcHandler = new AliMCEventHandler();
      mgr->SetMCtruthEventHandler(mcHandler);
      mcHandler->SetReadTR(useTR); 
   }   
   // AOD output container, created automatically when setting an AOD handler
   if (iAODhandler)
   {
      // AOD output handler
      AliAODHandler* aodHandler   = new AliAODHandler();
      aodHandler->SetOutputFileName("AliAOD.root");
      mgr->SetOutputEventHandler(aodHandler);
      if (iAODanalysis)
      {
         aodHandler->SetFillAOD(kFALSE);
         aodHandler->SetCreateNonStandardAOD();
         if (iJETAN)         aodHandler->SetOutputFileName("AliAOD.Jets.root");
//         if (iPWGHFvertexing) aodHandler->SetOutputFileName("AliAOD.VertexingHF.root");
      } 
   }
   // Debugging if needed
   if (useDBG) mgr->SetDebugLevel(3);
   if (saveCanvases) mgr->SetSaveCanvases(kTRUE);

   //==========================================================================
   // Create the chain. In this example it is created only from ALIEN files but
   // can be done to work in batch or grid mode as well.
   TChain *chain = CreateChain(smode, plugin_mode);
        
   //==========================================================================
   // Load the tasks configuration macros for all wagons. These files are supposed now to be
   // in the current workdir, but in AliEn they will be in the file catalog, 
   // mapped from AliRoot and pecified in the jdl input list.
    
   // For now connection to top input container and common AOD output container
   // is done in this macro, but in future these containers will be connected
   // from each task configuration macro.
                                                                                                                                           
   AddAnalysisTasks(cdbPath);                                                                                                                     
   // Run the analysis                                                                                                                     
   //                                                                                                                                      
   if (usePLUGIN)
   {
      AliAnalysisGrid *alienHandler = CreateAlienHandler(plugin_mode);                                                                     
      AliAnalysisManager::GetAnalysisManager()->SetGridHandler(alienHandler);                                                              
   }                                                                                                                                       
                                                                                                                                           
   if (mgr->InitAnalysis())
   {
      mgr->PrintStatus();                                                                                                                  
      if (saveTrain || strlen(config_file)) gSystem->ChangeDirectory(train_name);                                                          
      StartAnalysis(smode, chain);                                                                                                         
   }                                                                                                                                       
}                                                                                                                                          

//______________________________________________________________________________                                                           
void AddAnalysisTasks(const char *cdb_location)
{                                                                                                                                          
  // Add all analysis task wagons to the train                                                                                               
   AliAnalysisManager *mgr = AliAnalysisManager::GetAnalysisManager();                                                                     

  //
  // PIDResponse(JENS)
  //
  if (doPIDResponse)
  {
    gROOT->LoadMacro("$ALICE_ROOT/ANALYSIS/macros/AddTaskPIDResponse.C"); 
    AliAnalysisTaskPIDResponse *PIDResponse = AddTaskPIDResponse();
    // PIDResponse->SelectCollisionCandidates(AliVEvent::kAny);
  }

  //
  // Tender and supplies. Needs to be called for every event.
  //
  if (useTender)
  {
    gROOT->LoadMacro("$ALICE_PHYSICS/TENDER/TenderSupplies/AddTaskTender.C");
    // IF V0 tender needed, put kTRUE below
    AliAnalysisTaskSE *tender = AddTaskTender(kFALSE,kFALSE,kFALSE,kTRUE,kFALSE,kFALSE,kFALSE);
    // tender->SetDebugLevel(2);
   }

  // CDB connection
  //
  if (doCDBconnect /*&& !useTender*/)
  {
    gROOT->LoadMacro("$ALICE_PHYSICS/PWGPP/PilotTrain/AddTaskCDBconnect.C");
    AliTaskCDBconnect *taskCDB = AddTaskCDBconnect(cdb_location, run_number);
    if (!taskCDB) return;
//    AliCDBManager *cdb = AliCDBManager::Instance();
//    cdb->SetDefaultStorage(cdb_location);
//    taskCDB->SetRunNumber(run_numbers[0]);
  }    

   if (usePhysicsSelection)
   {
   // Physics selection task
      gROOT->LoadMacro("$ALICE_PHYSICS/OADB/macros/AddTaskPhysicsSelection.C");
      mgr->RegisterExtraFile("event_stat.root");
      AliPhysicsSelectionTask *physSelTask = AddTaskPhysicsSelection(useMC);
      mgr->AddStatisticsTask(AliVEvent::kAny);
   }
   
   if (useCentrality) 
   {
     //gROOT->LoadMacro("$ALICE_PHYSICS/OADB/macros/AddTaskCentrality.C");
     //AliCentralitySelectionTask *taskCentrality = AddTaskCentrality(); 
     gROOT->LoadMacro("$ALICE_PHYSICS/OADB/COMMON/MULTIPLICITY/macros/AddTaskMultSelection.C");
     AliMultSelectionTask *mult = AddTaskMultSelection();
   }
   
   //
  // PIDqa(JENS)
  //
  if (doPIDqa)
  {
    gROOT->LoadMacro("$ALICE_ROOT/ANALYSIS/macros/AddTaskPIDqa.C");
    AliAnalysisTaskPIDqa *PIDQA = AddTaskPIDqa();
    PIDQA->SelectCollisionCandidates(AliVEvent::kAny);
  }  


//Jacek
   if (iPWGPP)
   {
      gROOT->LoadMacro("$ALICE_PHYSICS/PWGPP/macros/AddTaskFilteredTree.C");
      AddTaskFilteredTree("FilterEvents_Trees.root");
   }   

// Muon refit
  if (iMUONRefit)
  {
    gROOT->LoadMacro("$ALICE_PHYSICS/PWG/muondep/AddTaskMuonRefit.C");
    AliAnalysisTaskMuonRefit* refit = AddTaskMuonRefit(-1., -1., kTRUE, -1., -1.);
    
    //refit->ReAlign("", 6, -1, "");
    refit->ReAlign("", 5, -1, "");
    
    refit->RemoveMonoCathodClusters(kTRUE, kFALSE);
  }
      
// --- PWGLF - Forward (cholm@nbi.dk) -----------------------------
   if (iPWGLFForward && usePhysicsSelection)
   {
        gROOT->LoadMacro("$ALICE_PHYSICS/PWGLF/FORWARD/analysis2/AddTaskForwardMult.C");
     UShort_t pwglfForwardSys = 0; // iCollision+1; // pp:1, PbPb:2, pPb:3
     UShort_t pwglfSNN        = 0;            // GeV, 0==unknown
     Short_t  pwglfField      = 0;
     AddTaskForwardMult(useMC && useTR,        // Need track-refs 
			pwglfForwardSys,       // Collision system
			pwglfSNN, 
			pwglfField);
        gROOT->LoadMacro("$ALICE_PHYSICS/PWGLF/FORWARD/analysis2/AddTaskCentralMult.C");
        AddTaskCentralMult(useMC, pwglfForwardSys, pwglfSNN, pwglfField);
   }
 
   if (iPWGGAgammaconv)
   {
      gROOT->LoadMacro("$ALICE_PHYSICS/PWGGA/GammaConv/macros/AddTask_ConversionAODProduction.C");
      AliAnalysisTask *taskconv = AddTask_ConversionAODProduction(iCollision, kFALSE, periodName);
      mgr->RegisterExtraFile("AliAODGammaConversion.root");
   }

   if (iESDfilter && !iAODanalysis) 
   {
      //  ESD filter task configuration.
      gROOT->LoadMacro("$ALICE_ROOT/ANALYSIS/ESDfilter/macros/AddTaskESDFilter.C");
      if (iMUONcopyAOD) {
         printf("Registering delta AOD file\n");
         mgr->RegisterExtraFile("AliAOD.Muons.root");
      }

      Bool_t muonWithSPDTracklets = (iCollision==1) ? kFALSE : kTRUE; // add SPD information to muon AOD only for pp

      AliAnalysisTaskESDfilter *taskesdfilter = 
                 AddTaskESDFilter(useKFILTER, 
                                  iMUONcopyAOD,          // write Muon AOD
                                  kFALSE,                // write dimuon AOD 
                                  kFALSE,                // usePhysicsSelection 
                                  kFALSE,                // centrality OBSOLETE
                                  kTRUE,                 // enable TPS only tracks
                                  kFALSE,                // disable cascades
                                  kFALSE,                // disable kinks
                                  run_flag,              // run flag (YY00)
                                  3,                     // muonMCMode
                                  kTRUE,                 // useV0Filter 
                                  muonWithSPDTracklets,
                                  isMuonCaloPass,        //
                                  iPWGGAgammaconv);      // addPCMV0s (new starting with v5-09-09, default is true)

         AliEMCALGeometry::GetInstance("","");
   }   

   // AOD tags
   if (useAODTAGS)
   {
      AliAnalysisTaskTagCreator* tagTask = new AliAnalysisTaskTagCreator("AOD Tag Creator");
      mgr->AddTask(tagTask);
      AliAnalysisDataContainer *coutTags = mgr->CreateContainer("cTag",  TTree::Class(), 
                                           AliAnalysisManager::kOutputContainer, "AOD.tag.root");
      mgr->ConnectInput (tagTask, 0, mgr->GetCommonInputContainer());
      mgr->ConnectOutput(tagTask, 1, coutTags);
   }   
    
// ********** PWG2 wagons ******************************************************
   AliAnalysisManager::SetCommonFileName("PWG2histograms.root");

   // Proton analysis
   if (iPWG2spectra)
   {
      // protons
      if (iPWG2protons) {
        gROOT->LoadMacro("$ALICE_ROOT/PWG2/SPECTRA/macros/AddTaskProtons.C");
        AliAnalysisTaskProtons *taskprotons = AddTaskProtons();
        if (!taskprotons) ::Warning("AnalysisTrainNew", "AliAnalysisTaskProtons cannot run for this train conditions - EXCLUDED");
      }  
      // cascades
      if (iPWG2checkcascade)
      {
        gROOT->LoadMacro("$ALICE_ROOT/PWG2/SPECTRA/macros/AddTaskCheckCascade.C");
        AliAnalysisTaskCheckCascade *taskcheckcascade = AddTaskCheckCascade(iCollision,runOnData);
        if (!taskcheckcascade) ::Warning("AnalysisTrainNew", "AliAnalysisTaskCheckCascade cannot run for this train conditions - EXCLUDED");
      }  
      // v0's
      if (iPWG2checkv0)
      {
        gROOT->LoadMacro("$ALICE_ROOT/PWG2/SPECTRA/macros/AddTaskCheckV0.C");
        AliAnalysisTaskCheckV0 *taskcheckV0 = AddTaskCheckV0();
        if (!taskcheckV0) ::Warning("AnalysisTrainNew", "AliAnalysisTaskCheckV0 cannot run for this train conditions - EXCLUDED");
      }  
      // strangeness
      if (iPWG2strange)
      {
        gROOT->LoadMacro("$ALICE_ROOT/PWG2/SPECTRA/macros/AddTaskStrange.C");
        AliAnalysisTaskStrange *taskstrange = AddTaskStrange();
        if (!taskstrange) ::Warning("AnalysisTrainNew", "AliAnalysisTaskStrange cannot run for this train conditions - EXCLUDED");
      }  
      // performance cascades
      if (iPWG2perfcascade)
      {
        gROOT->LoadMacro("$ALICE_ROOT/PWG2/SPECTRA/macros/AddTaskCheckPerformanceCascade.C");
        AliAnalysisTaskCheckPerformanceCascade *taskperfcascade = AddTaskCheckPerformanceCascade();
        if (!taskperfcascade) ::Warning("AnalysisTrainNew", "AliAnalysisTaskCheckPerformanceCascade cannot run for this train conditions - EXCLUDED");
      }  
       // central
      if (iPWG2central)
      {
        gROOT->LoadMacro("$ALICE_ROOT/PWG2/SPECTRA/macros/AddTaskCentral.C");
        AliAnalysisTaskCentral *taskcentral = AddTaskCentral();
        if (!taskcentral) ::Warning("AnalysisTrainNew", "AliAnalysisTaskCentral cannot run for this train conditions - EXCLUDED");
      }  
  }   
   
   // Femtoscopy analysis modules
   if (iPWG2femto)
   {
      gROOT->LoadMacro("$ALICE_ROOT/PWG2/FEMTOSCOPY/macros/AddTaskFemto.C");
      AliAnalysisTaskFemto *taskfemto = AddTaskFemto(configPWG2femto);
      if (!taskfemto) ::Warning("AnalysisTrainNew", "AliAnalysisTaskFemto cannot run for this train conditions - EXCLUDED");
   }   

   // Kink analysis
   if (iPWG2kink)
   {
      if (iPWG2kinkESDMC)
      {
        gROOT->LoadMacro("$ALICE_ROOT/PWG2/KINK/macros/AddTaskKink.C");
        AliAnalysisKinkESDMC *taskkink1 = AddTaskKink();
        if (!taskkink1) ::Warning("AnalysisTrainNew", "AliAnalysisKinkESDMC cannot run for this train conditions - EXCLUDED");
      }   
      if (iPWG2kinkLSKstar)
      {
        gROOT->LoadMacro("$ALICE_ROOT/PWG2/KINK/macros/AddTaskKinkResLikeSignKstar.C");
        AliResonanceKinkLikeSign *taskkink2 = AddTaskKinkResLikeSignKstar();
        if (!taskkink2) ::Warning("AnalysisTrainNew", "AliResonanceKinkLikeSign cannot run for this train conditions - EXCLUDED");
      }  
      if (iPWG2kinkLSL1520)
      {
        gROOT->LoadMacro("$ALICE_ROOT/PWG2/KINK/macros/AddTaskKinkResLikeSignL1520.C");
        AliResonanceKinkLikeSign *taskkink3 = AddTaskKinkResLikeSignL1520();
        if (!taskkink3) ::Warning("AnalysisTrainNew", "AliResonanceKinkLikeSign cannot run for this train conditions - EXCLUDED");
      }  
      if (iPWG2kinkLSPhi)
      {
        gROOT->LoadMacro("$ALICE_ROOT/PWG2/KINK/macros/AddTaskKinkResLikeSignPhi.C");
        AliResonanceKinkLikeSign *taskkink4 = AddTaskKinkResLikeSignPhi();
        if (!taskkink4) ::Warning("AnalysisTrainNew", "AliResonanceKinkLikeSign cannot run for this train conditions - EXCLUDED");
      }  
      if (iPWG2kinkKstarESD)
      {
        gROOT->LoadMacro("$ALICE_ROOT/PWG2/KINK/macros/AddTaskKinkResonanceKstarESD.C");
        AliAnalysisTaskKinkResonance *taskkink5 = AddTaskKinkResonanceKstarESD();
        if (!taskkink5) ::Warning("AnalysisTrainNew", "AliAnalysisKinkResonanceKstarESD cannot run for this train conditions - EXCLUDED");
      }   
      if (iPWG2kinkKstarMC)
      {
        gROOT->LoadMacro("$ALICE_ROOT/PWG2/KINK/macros/AddTaskKinkResonanceKstarMC.C");
        AliAnalysisTaskKinkResonance *taskkink6 = AddTaskKinkResonanceKstarMC();
        if (!taskkink6) ::Warning("AnalysisTrainNew", "AliAnalysisKinkResonanceKstarMC cannot run for this train conditions - EXCLUDED");
      }   
      if (iPWG2kinkL1520ESD)
      {
        gROOT->LoadMacro("$ALICE_ROOT/PWG2/KINK/macros/AddTaskKinkResonanceL1520ESD.C");
        AliAnalysisTaskKinkResonance *taskkink7 = AddTaskKinkResonanceL1520ESD();
        if (!taskkink7) ::Warning("AnalysisTrainNew", "AliAnalysisKinkResonanceL1520ESD cannot run for this train conditions - EXCLUDED");
      }   
      if (iPWG2kinkL1520MC)
      {
        gROOT->LoadMacro("$ALICE_ROOT/PWG2/KINK/macros/AddTaskKinkResonanceL1520MC.C");
        AliAnalysisTaskKinkResonance *taskkink8 = AddTaskKinkResonanceL1520MC();
        if (!taskkink8) ::Warning("AnalysisTrainNew", "AliAnalysisKinkResonanceL1520MC cannot run for this train conditions - EXCLUDED");
      }   
      if (iPWG2kinkPhiESD)
      {
        gROOT->LoadMacro("$ALICE_ROOT/PWG2/KINK/macros/AddTaskKinkResonancePhiESD.C");
        AliAnalysisTaskKinkResonance *taskkink9 = AddTaskKinkResonancePhiESD();
        if (!taskkink9) ::Warning("AnalysisTrainNew", "AliAnalysisKinkResonancePhiESD cannot run for this train conditions - EXCLUDED");
      }   
      if (iPWG2kinkPhiMC)
      {
        gROOT->LoadMacro("$ALICE_ROOT/PWG2/KINK/macros/AddTaskKinkResonancePhiMC.C");
        AliAnalysisTaskKinkResonance *taskkink10 = AddTaskKinkResonancePhiMC();
        if (!taskkink10) ::Warning("AnalysisTrainNew", "AliAnalysisKinkResonancePhiMC cannot run for this train conditions - EXCLUDED");
      }   
   }   

   // Event characterization
   if (iPWG2evchar)
   {
      gROOT->LoadMacro("$ALICE_ROOT/PWG2/EVCHAR/macros/AddTaskSPDdNdEta.C");
      AliAnalysisTaskSPDdNdEta *taskspddndeta = AddTaskSPDdNdEta();
      if (!taskspddndeta) ::Warning("AnalysisTrainNew", "AliAnalysisTaskSPDdNdEta cannot run for this train conditions - EXCLUDED");
      taskspddndeta->SetReadMC(useMC);
   }   

   // Unicor
   if (iPWG2unicor)
   {
      gROOT->LoadMacro("$ALICE_ROOT/PWG2/UNICOR/AddTaskUnicor.C");
      AliAnalysisTaskUnicor *taskunicor = AddTaskUnicor();
      if (!taskunicor) ::Warning("AnalysisTrainNew", "AliAnalysisTaskUnicor cannot run for this train conditions - EXCLUDED");
   }   

   AliAnalysisManager::SetCommonFileName("PWG2histograms.root");

   // Flow analysis
   if (iPWG2flow)
   {
      gROOT->LoadMacro("$ALICE_ROOT/PWG2/FLOW/macros/AddTaskFlow.C");
      Bool_t SP       = kTRUE;
      Bool_t LYZ1SUM  = kTRUE;
      Bool_t LYZ1PROD = kTRUE;
      Bool_t LYZ2SUM  = kFALSE; 
      Bool_t LYZ2PROD = kFALSE;
      Bool_t LYZEP    = kFALSE; 
      Bool_t GFC      = kTRUE;
      Bool_t QC       = kTRUE;
      Bool_t FQD      = kFALSE;
      Bool_t MCEP     = kFALSE; //does not work yet 24/12/08
      Bool_t kineFromESD = kTRUE;
      Bool_t METHODS[] = {SP,LYZ1SUM,LYZ1PROD,LYZ2SUM,LYZ2PROD,LYZEP,GFC,QC,FQD,MCEP};
      // Analysis type can be ESD, AOD, MC, ESDMC0, ESDMC1
      TString type = "AOD";
      if (!iAODanalysis) type = "ESD";
      // Boolean to fill/not fill the QA histograms
      Bool_t QA = kTRUE;   
      // Boolean to use/not use weights for the Q vector
      Bool_t WEIGHTS[] = {kFALSE,kFALSE,kFALSE}; //Phi, v'(pt), v'(eta)
      AliAnalysisTaskFlowEvent* taskFE = AddTaskFlow(type,METHODS,QA,WEIGHTS);
      if (!taskFE) ::Warning("AnalysisTrainNew", "AliAnalysisTaskFlowEvent cannot run for this train conditions - EXCLUDED");
   }   

   // PWG2 resonances
   AliAnalysisManager::SetCommonFileName("resonances.root");
   if (iPWG2res)
   {
      gROOT->LoadMacro("$ALICE_ROOT/PWG2/RESONANCES/macros/train/AddAnalysisTaskRsnNew.C");
      gROOT->LoadMacro("$ALICE_ROOT/PWG2/RESONANCES/macros/train/AddAnalysisTaskRsnEffNew.C");
      TString path = gROOT->GetMacroPath();
      path += ":$ALICE_ROOT/PWG2/RESONANCES/macros/train";
      gROOT->SetMacroPath(path);
      AddAnalysisTaskRsn(kTRUE);
      if (iPWG2rsneff) AddAnalysisTaskRsnEff();
   }   
   AliAnalysisManager::SetCommonFileName("PWG2histograms.root");

// ********** PWG3 wagons ******************************************************
   AliAnalysisManager::SetCommonFileName("PWG3histograms.root");
           
   // PWG3 vertexing
  if (iPWGHFvertexing) 
  {
    gROOT->LoadMacro("$ALICE_PHYSICS/PWGHF/vertexingHF/macros/AddTaskVertexingHF.C");

    AliAnalysisTaskSEVertexingHF *taskvertexingHF = AddTaskVertexingHF(iCollision,train_name,"",run_number,periodName);
    // Now we need to keep in sync with the ESD filter
    if (!taskvertexingHF) ::Warning("AnalysisTrainNew", "AliAnalysisTaskSEVertexingHF cannot run for this train conditions - EXCLUDED");
    else mgr->RegisterExtraFile("AliAOD.VertexingHF.root");
    taskvertexingHF->SelectCollisionCandidates(0);
  }
      
   // PWG3 electrons
   if (iPWG3hfe)
   {
      gROOT->LoadMacro("$ALICE_ROOT/PWG3/hfe/AddTaskHFE.C");
      AliAnalysisTaskHFE *taskHFE = AddTaskHFE();
      if (!taskHFE) ::Warning("AnalysisTrainNew", "AliAnalysisTaskHFE cannot run for this train conditions - EXCLUDED");
   }   

   // PWG3 JPSI filtering
   if (iPWGDQJPSIfilter)
   {
      gROOT->LoadMacro("$ALICE_ROOT/PWGDQ/dielectron/macros/AddTaskJPSIFilter.C");
      AliAnalysisTaskSE *taskJPSIfilter = AddTaskJPSIFilter();
      if (!taskJPSIfilter) ::Warning("AnalysisTrainNew", "AliAnalysisTaskDielectronFilter cannot run for this train conditions - EXCLUDED");
      else mgr->RegisterExtraFile("AliAOD.Dielectron.root");
      taskJPSIfilter->SelectCollisionCandidates(0);
   }   

   // PWG3 JPSI
   if (iPWGDQJPSI) 
   {
      gROOT->LoadMacro("$ALICE_ROOT/PWGDQ/dielectron/macros/AddTaskJPSI.C");
      AliAnalysisTask *taskJPSI = AddTaskJPSI();
      if (!taskJPSI) ::Warning("AnalysisTrainNew", "AliAnalysisTaskMultiDielectron cannot run for this train conditions - EXCLUDED");
   }   

   // PWG3 D2h
   if (iPWGHFd2h) 
   {   
     gROOT->LoadMacro("$ALICE_PHYSICS/PWGHF/vertexingHF/AddD2HTrain.C");
     //TFile::Cp(gSystem->ExpandPathName(configPWG3d2h.Data()), 
     //          Form("%s/ConfigVertexingHF.C", train_name.Data()));
     
     AddD2HTrain(kFALSE, 1,0,0,0,0,0,0,0,0,0,0);                                 
   }

   // PWG3 muon
   if (iPWGMuonTrain)
   {
      gROOT->LoadMacro("$ALICE_ROOT/PWG/muon/AddPWG3MuonTrain.C");
      // iESDAnalysis, iAODAnalysis -> flags to select if the train is AOD or ESD based
      // iMuonDistributions, iSingleMuonANAlysis -> flags to switch on/off analysis wagons
      Int_t isESDAnalysis = (iAODanalysis)?0:1;
      Int_t isAODAnalysis = (iAODanalysis)?1:0;
      Int_t addMuonDistributions = 1;
      Int_t addSingleMuonAnalysis = 1;
      Int_t addMuonHFAnalysis = 1;
      Int_t ntaskmuon = AddPWG3MuonTrain(isESDAnalysis,isAODAnalysis,addMuonDistributions,addSingleMuonAnalysis,addMuonHFAnalysis);
      printf("Added %d muon tasks\n", ntaskmuon);
   }
   
   // ********** PWG4 wagons ******************************************************
   AliAnalysisManager::SetCommonFileName("PWG4histograms.root");

   // Jet analysis

   // Configurations flags, move up?
   TString kDeltaAODJetName = "AliAOD.Jets.root"; //
   Bool_t  kIsPbPb = true; // can be more intlligent checking the name of the data set
   TString kDefaultJetBackgroundBranch = "";
   TString kJetSubtractBranches = "";
   UInt_t kHighPtFilterMask = 768;// from esd filter
   if(run_flag==1000)kHighPtFilterMask = 272;// from esd filter for 2010
   UInt_t iPhysicsSelectionFlag = 0;
   if (iJETAN)
   {
     gROOT->LoadMacro("$ALICE_PHYSICS/PWGJE/macros/AddTaskJets.C");
     if (!iAODanalysis) 
     {
       // Default jet reconstructor running on ESD's
       AliAnalysisTaskJets *taskjets = AddTaskJets("AOD","UA1",0.4,kHighPtFilterMask,1.,0); // no background subtraction     
       if(kDeltaAODJetName.Length()>0)taskjets->SetNonStdOutputFile(kDeltaAODJetName.Data());
       if (!taskjets) ::Warning("AnalysisTrainNew", "AliAnalysisTaskJets cannot run for this train conditions - EXCLUDED");
       if (iJETANdelta)
       {
	 //            AddTaskJetsDelta("AliAOD.Jets.root"); // need to modify this accordingly in the add task jets
	 mgr->RegisterExtraFile(kDeltaAODJetName.Data());
	 TString cTmp("");
	 if(kIsPbPb)
         {
	   // UA1 intrinsic background subtraction
	   taskjets = AddTaskJets("AOD","UA1",0.4,kHighPtFilterMask,1.,2); // background subtraction
 	   if(kDeltaAODJetName.Length()>0)taskjets->SetNonStdOutputFile(kDeltaAODJetName.Data());
	 }

	 // Add the clusters..
	 gROOT->LoadMacro("$ALICE_ROOT/PWGJE/macros/AddTaskJetCluster.C");
	 AliAnalysisTaskJetCluster *taskCl = 0;
	 Float_t fCenUp = 0;
	 Float_t fCenLo = 0;
	 Float_t fTrackEtaWindow = 0.9;
	 taskCl = AddTaskJetCluster("AOD","",kHighPtFilterMask,iPhysicsSelectionFlag,"KT",0.4,0,1, kDeltaAODJetName.Data(),0.15,fTrackEtaWindow,0); // this one is for the background and random jets, random cones with no skip                                                                                 
	 taskCl->SetBackgroundCalc(kTRUE);
	 taskCl->SetNRandomCones(1);
	 taskCl->SetCentralityCut(fCenLo,fCenUp);
	 taskCl->SetGhostEtamax(fTrackEtaWindow);
	 kDefaultJetBackgroundBranch = Form("%s_%s",AliAODJetEventBackground::StdBranchName(),taskCl->GetJetOutputBranch());

	 taskCl = AddTaskJetCluster("AOD","",kHighPtFilterMask,iPhysicsSelectionFlag,"ANTIKT",0.4,0,1,kDeltaAODJetName.Data(),0.15);
	 taskCl->SetCentralityCut(fCenLo,fCenUp);
	 if(kIsPbPb)taskCl->SetBackgroundBranch(kDefaultJetBackgroundBranch.Data());
	 kJetSubtractBranches += Form("%s ",taskCl->GetJetOutputBranch());

	 taskCl = AddTaskJetCluster("AOD","",kHighPtFilterMask,iPhysicsSelectionFlag,"ANTIKT",0.3,0,1,kDeltaAODJetName.Data(),0.15);
	 taskCl->SetCentralityCut(fCenLo,fCenUp);
	 if(kIsPbPb)taskCl->SetBackgroundBranch(kDefaultJetBackgroundBranch.Data());
	 kJetSubtractBranches += Form("%s ",taskCl->GetJetOutputBranch());
	 
	 // DO THE BACKGROUND SUBTRACTION
	 if(kIsPbPb&&kJetSubtractBranches.Length()){
	   gROOT->LoadMacro("$ALICE_ROOT/PWGJE/macros/AddTaskJetBackgroundSubtract.C");
	   AliAnalysisTaskJetBackgroundSubtract *taskSubtract = 0;
	   taskSubtract = AddTaskJetBackgroundSubtract(kJetSubtractBranches,1,"B0","B%d");
	   taskSubtract->SetBackgroundBranch(kDefaultJetBackgroundBranch.Data());
	   if(kDeltaAODJetName.Length()>0)taskSubtract->SetNonStdOutputFile(kDeltaAODJetName.Data());
	 }
       } 
     } 
     else 
     {
       // AOD-based analysis. Add all reconstructors to write into delta AOD's
       if (iJETANdelta) 
       {
	 Int_t ntasksjets = AddTaskJetsDelta("AliAOD.Jets.root",0,kFALSE);
	 if (ntasksjets) printf("Added %d jet reconstructors\n", ntasksjets);
       }
     }    
   }
     
   // PWG4 hadron correlations
   if (iPWG4partcorr) 
   {
      Bool_t isSimulation = (runOnData)?kFALSE:kTRUE;
      gROOT->LoadMacro("$ALICE_ROOT/PWGJE/macros/AddTaskPartCorr.C");
      AliAnalysisTaskParticleCorrelation *taskpartcorrPHOS = AddTaskPartCorr("AOD", "PHOS", kFALSE, isSimulation);
      if (!taskpartcorrPHOS) ::Warning("AnalysisTrainNew", "AliAnalysisTaskParticleCorrelation PHOS cannot run for this train conditions - EXCLUDED");
      AliAnalysisTaskParticleCorrelation *taskpartcorrEMCAL = AddTaskPartCorr("AOD", "EMCAL", kFALSE, isSimulation);
      if (!taskpartcorrEMCAL) ::Warning("AnalysisTrainNew", "AliAnalysisTaskParticleCorrelation EMCAL cannot run for this train conditions - EXCLUDED");
      mgr->RegisterExtraFile("deltaAODPartCorr.root");
   }   

   // PWG4 omega to 3 pions analysis
   if (iPWG4omega3pi) 
   {
      gROOT->LoadMacro("$ALICE_ROOT/PWG4/macros/AddTaskomega3pi.C");
      AliAnalysisTaskOmegaPi0PiPi *taskomega3pi = AddTaskomega3pi();
      if (!taskomega3pi) ::Warning("AnalysisTrainNew", "AliAnalysisTaskomega3pi cannot run for these train conditions - EXCLUDED");
   }
}

//______________________________________________________________________________
void StartAnalysis(const char *mode, TChain *chain) {
// Start analysis.
   Int_t imode = -1;
   AliAnalysisManager *mgr = AliAnalysisManager::GetAnalysisManager();
   if (!strcmp(mode, "LOCAL")) imode = 0;
   if (!strcmp(mode, "PROOF")) imode = 1;
   if (!strcmp(mode, "GRID"))  imode = 2;
   switch (imode) {
      case 0:
         if (!chain) {
            ::Error("AnalysisTrainNew.C::StartAnalysis", "Cannot create the chain");
            return;
         }   
         mgr->StartAnalysis(mode, chain);
         return;
      case 1:
         if (!proof_dataset.Length()) {
            ::Error("AnalysisTrainNew.C::StartAnalysis", "proof_dataset is empty");
            return;
         }   
         mgr->StartAnalysis(mode, proof_dataset, 1000);
         return;
      case 2:
         if (usePLUGIN) {
            if (!mgr->GetGridHandler()) {
               ::Error("AnalysisTrainNew.C::StartAnalysis", "Grid plugin not initialized");
               return;
            }   
            mgr->StartAnalysis("grid");
         } else {
            if (!chain) {
               ::Error("AnalysisTrainNew.C::StartAnalysis", "Cannot create the chain");
               return;
            }   
            mgr->StartAnalysis(mode, chain);
         }   
         return;
   }      
}          
    
//______________________________________________________________________________
void CheckModuleFlags(const char *mode) {
// Checks selected modules and insure compatibility
   Int_t imode = -1;
   if (!strcmp(mode, "LOCAL")) imode = 0;
   if (!strcmp(mode, "PROOF")) imode = 1;
   if (!strcmp(mode, "GRID"))  imode = 2;
   if (!iJETAN) iJETANdelta = 0;
   if (imode==1) {
      if (!usePAR) {
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "PAR files enabled due to PROOF analysis");
         usePAR = kTRUE;
      }   
   }  
   if (imode != 2) {
      ::Info("AnalysisTrainNew.C::CheckModuleFlags", "AliEn plugin disabled since not in GRID mode");
      usePLUGIN = kFALSE; 
   }   
   if (iAODanalysis) {
   // AOD analysis
      if (useMC)
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "MC usage disabled in analysis on AOD's");
      if (useAODTAGS)
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "AOD tags usage disabled in analysis on AOD's");
      useMC = kFALSE;
      useTR = kFALSE;
      useAODTAGS = kFALSE;
      if (iESDfilter)
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "ESD filter disabled in analysis on AOD's");
      iESDfilter   = 0;
      if (!iAODhandler) {
         if (iJETAN) 
            ::Info("AnalysisTrainNew.C::CheckModuleFlags", "JETAN disabled in analysis on AOD's without AOD handler");
         iJETAN = 0;
         iJETANdelta = 0;
      }
      // Disable tasks that do not work yet on AOD data
      if (iPWGGAgammaconv)
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "PWG4gammaconv disabled on AOD's without AOD handler");
      iPWGGAgammaconv = 0;   
      if (iPWG2central)
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "PWG2central disabled on AOD's");
         iPWG2central = 0;
      if (iPWG2flow)
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "PWG2flow disabled on AOD's");
         iPWG2flow = 0;
      if (iPWG2femto)
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "PWG2femto disabled on AOD's");
         iPWG2femto = 0;
      if (iPWG2res)
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "PWG2res disabled on AOD's");
         iPWG2res = 0;
       if (iPWG2rsneff)
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "PWG2rsneff disabled on AOD's");
         iPWG2rsneff = 0;
     if (iPWG2kink)         
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "PWG2kink disabled in analysis on AOD's");
         iPWG2kink = 0;
      if (iPWG2unicor)         
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "PWG2unicor disabled in analysis on AOD's");
         iPWG2unicor = 0;
      if (iPWG2evchar)
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "PWG4evchar disabled on AOD's");
         iPWG2evchar = 0;
      if (iPWG2forward)         
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "PWG2forward disabled in analysis on AOD's");
         iPWG2forward = 0;
      if (iPWG3hfe)
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "PWG3hfe disabled on AOD's");
         iPWG3hfe = 0;
      if (iPWG4omega3pi)
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "PWG4omega3pi disabled on AOD's");
         iPWG4omega3pi = 0;
   } else {   
   // ESD analysis
      if (!useMC) useTR = kFALSE;
   }
   if (!useMC) {
      if (iPWG2perfcascade)
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "PWG2perfcascade disabled without MC info");
      iPWG2perfcascade = 0;   
      if (iPWG2central)
         ::Info("AnalysisTrainNew.C::CheckModuleFlags", "PWG2central disabled without MC info");
         iPWG2central = 0;
   }   
   if (iJETAN && !iAODanalysis) iESDfilter=1;
   if (iESDfilter) {iAODhandler=1; useCORRFW = kTRUE;}
   if (iPWG2spectra || iPWG2flow || iPWGHFvertexing || iPWG3hfe || iPWG2res || iPWG2rsneff) useCORRFW = kTRUE;
   if (useKFILTER && !useMC) useKFILTER = kFALSE;
   if (useAODTAGS && !iAODhandler) useAODTAGS = kFALSE;
}

//______________________________________________________________________________
Bool_t Connect(const char *mode) {
// Connect <username> to the back-end system.
   Int_t imode = -1;
   if (!strcmp(mode, "LOCAL")) imode = 0;
   if (!strcmp(mode, "PROOF")) imode = 1;
   if (!strcmp(mode, "GRID"))  imode = 2;
   TString username = gSystem->Getenv("alien_API_USER");
   switch (imode) {
      case 0:
         break;
      case 1:
         if  (!username.Length()) {
            ::Error(Form("AnalysisTrainNew.C::Connect <%s>", mode), "Make sure you:\n \
                           1. Have called: alien-token-init <username>\n \
                           2. Have called: >source /tmp/gclient_env_$UID");
            return kFALSE;
         }
         ::Info("AnalysisTrainNew.C::Connect", "Connecting user <%s> to PROOF cluster <%s>", 
                username.Data(), proof_cluster.Data());
         gEnv->SetValue("XSec.GSI.DelegProxy", "2");
//         TProof::Open(Form("%s@%s:31093", username.Data(), proof_cluster.Data()));       
         TProof::Open(Form("%s@%s", username.Data(), proof_cluster.Data()));       
         if (!gProof) {
            if (strcmp(gSystem->Getenv("XrdSecGSISRVNAMES"), "lxfsrd0506.cern.ch"))
               ::Error(Form("AnalysisTrainNew.C::Connect <%s>", mode), "Environment XrdSecGSISRVNAMES different from lxfsrd0506.cern.ch");
            return kFALSE;
         }
         TGrid::Connect("alien://");
         if (gGrid) {
            TString homedir = gGrid->GetHomeDirectory();
            TString workdir = homedir + train_name;
            if (!gGrid->Cd(workdir)) {
               gGrid->Cd(homedir);
               if (gGrid->Mkdir(workdir)) {
                  gGrid->Cd(train_name);
                  ::Info("AnalysisTrainNew::Connect()", "Directory %s created", gGrid->Pwd());
               }
            }
            gGrid->Mkdir("proof_output");
            gGrid->Cd("proof_output");
            proof_outdir = Form("alien://%s", gGrid->Pwd());
         }   
         break;
      case 2:      
         if (usePLUGIN && !gSystem->Getenv("alien_CLOSE_SE")) {
            ::Error(Form("AnalysisTrainNew.C::Connect <%s>", mode), 
                           "When using the AliEn plugin it is preferable to define the \
                           variable alien_CLOSE_SE in your environment.");
            return kFALSE;
         }
         ::Info("AnalysisTrainNew.C::Connect", "Connecting user <%s> to AliEn ...", 
                username.Data());
         TGrid::Connect("alien://");
         if (!gGrid || !gGrid->IsConnected()) return kFALSE;
         break;
      default:
         ::Error("AnalysisTrainNew.C::Connect", "Unknown run mode: %s", mode);
         return kFALSE;
   }
   ::Info("AnalysisTrainNew.C::Connect","Connected in %s mode", mode);
   return kTRUE;
}

//______________________________________________________________________________
Bool_t LoadCommonLibraries(const char *mode)
{
// Load common analysis libraries.
   Int_t imode = -1;
   if (!strcmp(mode, "LOCAL")) imode = 0;
   if (!strcmp(mode, "PROOF")) imode = 1;
   if (!strcmp(mode, "GRID"))  imode = 2;
   if (!gSystem->Getenv("ALICE_ROOT")) {
      ::Error("AnalysisTrainNew.C::LoadCommonLibraries", "Analysis train requires that analysis libraries are compiled with a local AliRoot"); 
      return kFALSE;
   }   
   Bool_t success = kTRUE;
   // ROOT libraries
   gSystem->Load("libTree.so");
   gSystem->Load("libGeom.so");
   gSystem->Load("libVMC.so");
   gSystem->Load("libPhysics.so");
   gSystem->Load("libMinuit.so");
   
   // Load framework classes. Par option ignored here.
   switch (imode) {
      case 0:
      case 2:
         if (useCPAR) {
            success &= LoadLibrary("STEERBase", mode, kTRUE);
            success &= LoadLibrary("ESD", mode, kTRUE);
            success &= LoadLibrary("AOD", mode, kTRUE);
            success &= LoadLibrary("ANALYSIS", mode, kTRUE);
            success &= LoadLibrary("ANALYSISalice", mode, kTRUE);
            success &= LoadLibrary("ESDfilter", mode, kTRUE);
            if (useCORRFW) success &= LoadLibrary("CORRFW", mode, kTRUE);
         } else {   
            success &= LoadLibrary("libSTEERBase.so", mode);
            success &= LoadLibrary("libESD.so", mode);
            success &= LoadLibrary("libAOD.so", mode);
            success &= LoadLibrary("libANALYSIS.so", mode);
            success &= LoadLibrary("libANALYSISalice.so", mode);
            success &= LoadLibrary("ESDfilter", mode, kTRUE);
            if (useCORRFW) success &= LoadLibrary("libCORRFW.so", mode);
            gROOT->ProcessLine(".include $ALICE_ROOT/include");
         }   
         break;
      case 1:
         Int_t ires = -1;
         if (useAFPAR && !gSystem->AccessPathName(AFversion)) ires = gProof->UploadPackage(AFversion);
         if (ires < 0) {
            success &= LoadLibrary("STEERBase", mode);
            success &= LoadLibrary("ESD", mode);
            success &= LoadLibrary("AOD", mode);
            success &= LoadLibrary("ANALYSIS", mode);
            success &= LoadLibrary("ANALYSISalice", mode);
            success &= LoadLibrary("ESDfilter", mode);
            if (useCORRFW) success &= LoadLibrary("CORRFW", mode);
         } else { 
            ires = gProof->EnablePackage(AFversion);
            if (ires<0) success = kFALSE;
            if (useCORRFW) success &= LoadLibrary("CORRFW", mode);
         }
         break;         
      default:
         ::Error("AnalysisTrainNew.C::LoadCommonLibraries", "Unknown run mode: %s", mode);
         return kFALSE;
   }
   if (success) {
      ::Info("AnalysisTrainNew.C::LoadCommodLibraries", "Load common libraries:    SUCCESS");
      ::Info("AnalysisTrainNew.C::LoadCommodLibraries", "Include path for Aclic compilation:\n%s",
              gSystem->GetIncludePath());
   } else {           
      ::Info("AnalysisTrainNew.C::LoadCommodLibraries", "Load common libraries:    FAILED");
   }   
      
   return success;
}

//______________________________________________________________________________
Bool_t LoadAnalysisLibraries(const char *mode)
{
// Load common analysis libraries.
   Bool_t success = kTRUE;
   if (useTender || doCDBconnect) {
      if (!LoadLibrary("Tender", mode, kTRUE) ||
          !LoadLibrary("TenderSupplies", mode, kTRUE)) return kFALSE;
   }       
   // CDBconnect
   if (doCDBconnect && !useTender) {
      if (!LoadLibrary("PWGPP", mode, kTRUE)) return kFALSE;
   }
      
   if (iESDfilter || iPWGMuonTrain) {
      if (!LoadLibrary("PWGmuon", mode, kTRUE)) return kFALSE;
   }   
   // JETAN
   if (iJETAN) {
      if (!LoadLibrary("JETAN", mode, kTRUE)) return kFALSE;
   }
   if (iJETANdelta) {
      if (!LoadLibrary("CGAL", mode, kTRUE) ||
          !LoadLibrary("fastjet", mode, kTRUE) ||
          !LoadLibrary("siscone", mode, kTRUE) ||
          !LoadLibrary("siscone_spherical", mode, kTRUE) ||
          !LoadLibrary("fastjetplugins", mode, kTRUE) ||
          !LoadLibrary("fastjettools", mode, kTRUE) ||
          !LoadLibrary("fastjetcontribfragile", mode, kTRUE) ||
          !LoadLibrary("JETAN", mode, kTRUE) ||
          !LoadLibrary("PWGJEEMCALJetTasks", mode, kTRUE)
          //!LoadLibrary("FASTJETAN", mode, kTRUE)
        ) 
        return kFALSE;
   }

   // PWG4 particle correlations
   if (iPWG4partcorr) {   
      if (!LoadLibrary("EMCALUtils", mode, kTRUE) ||
          !LoadLibrary("PHOSUtils", mode, kTRUE) ||
          !LoadLibrary("PWG4PartCorrBase", mode, kTRUE) ||
          !LoadLibrary("PWG4PartCorrDep", mode, kTRUE)) return kFALSE;
   }
   // PWG4 gamma conversion
   if (iPWGGAgammaconv) {
      if (!LoadLibrary("PWGGAGammaConv", mode, kTRUE)) return kFALSE;
   }      
   // PWG4 omega to 3 pions
   if (iPWG4omega3pi) {
      if (!LoadLibrary("PWG4omega3pi", mode, kTRUE)) return kFALSE;
   }      
   // PWG2 task protons 
   if (iPWG2spectra) {
      if (!LoadLibrary("PWG2spectra", mode, kTRUE)) return kFALSE;
   }
   // PWG2 flow
   if (iPWG2flow) {
      if (!LoadLibrary("PWG2flowCommon", mode, kTRUE) ||
          !LoadLibrary("PWG2flowTasks", mode, kTRUE)) return kFALSE;
   }
   // PWG2 resonances
   if (iPWG2res || iPWG2rsneff) {
      if (!LoadLibrary("PWG2resonances", mode, kTRUE)) return kFALSE;
   }   
   // PWG2 kink
   if (iPWG2kink) {
      if (!LoadLibrary("PWG2kink", mode, kTRUE)) return kFALSE;
   }   
   // PWG2 unicor
   if (iPWG2unicor) {
      if (!LoadLibrary("PWG2unicor", mode, kTRUE)) return kFALSE;
   }   
   // PWG2 evchar
   if (iPWG2evchar) {
      if (!LoadLibrary("PWG2evchar", mode, kTRUE)) return kFALSE;
   }   
   // PWG2 femtoscopy
   if (iPWG2femto) {
      if (!LoadLibrary("PWG2AOD", mode, kTRUE) ||
          !LoadLibrary("PWG2femtoscopy", mode, kTRUE) ||
          !LoadLibrary("PWG2femtoscopyUser", mode, kTRUE)) return kFALSE;
//      TFile::Cp(gSystem->ExpandPathName("$(ALICE_ROOT)/PWG2/FEMTOSCOPY/macros/ConfigFemtoAnalysis.C"), Form("%s/ConfigFemtoAnalysis.C", train_name.Data()));
//      anaLibs += "ConfigFemtoAnalysis.C ";
   }   
   // PWG2 FORWARD
   if (iPWGLFForward) {
//      if (!LoadLibrary("PWGLFforward", mode, kTRUE)) return kFALSE;
      if (!LoadLibrary("PWGLFforward2", mode, kTRUE)) return kFALSE;
   }   
    // PWG3 Vertexing HF
   if (iPWGHFvertexing || iPWGHFd2h) {
      if (!LoadLibrary("PWGflowBase", mode, kTRUE) ||
          !LoadLibrary("PWGflowTasks", mode, kTRUE) ||
          !LoadLibrary("PWGHFvertexingHF", mode, kTRUE)) return kFALSE;
   }   
   // PWG3 hfe
   if (iPWG3hfe) {
      if (!LoadLibrary("PWG3hfe", mode, kTRUE)) return kFALSE;
   }   
   // PWG3 dielectron
   if (iPWGDQJPSIfilter || iPWGDQJPSI) {
      if (!LoadLibrary("PWGDQdielectron", mode, kTRUE)) return kFALSE;
   }   
   if (iPWGLFForward) {
      if (!LoadLibrary("Tender", mode, kTRUE)  || !LoadLibrary("PWGUDbase", mode, kTRUE)  ||
       !LoadLibrary("TPCcalib", mode, kTRUE)  ||
       !LoadLibrary("PWGPP", mode, kTRUE)  ||
       !LoadLibrary("PWGLFspectra", mode, kTRUE)) return kFALSE;
   }   
   ::Info("AnalysisTrainNew.C::LoadAnalysisLibraries", "Load other libraries:   SUCCESS");
   return kTRUE;
}

//______________________________________________________________________________
Bool_t LoadLibrary(const char *module, const char *mode, Bool_t rec=kFALSE)
{
// Load a module library in a given mode. Reports success.
   Int_t imode = -1;
   Int_t result;
   TString smodule(module);
   if (!strcmp(mode, "LOCAL")) imode = 0;
   if (!strcmp(mode, "PROOF")) imode = 1;
   if (!strcmp(mode, "GRID"))  imode = 2;
   TString mod(module);
   if (!mod.Length()) {
      ::Error("AnalysisTrainNew.C::LoadLibrary", "Empty module name");
      return kFALSE;
   }   
   // If a library is specified, just load it
   if (smodule.EndsWith(".so")) {
      mod.Remove(mod.Index(".so"));
      result = gSystem->Load(mod);
      if (result < 0) {
         ::Error("AnalysisTrainNew.C::LoadLibrary", "Could not load library %s", module);
         return kFALSE;
      }
      if (rec) anaLibs += Form("%s.so ",mod.Data()); 
      return kTRUE;
   } 
   // Check if the library is already loaded
   if (strlen(gSystem->GetLibraries(Form("%s.so", module), "", kFALSE)) > 0)
      return kTRUE;    
   switch (imode) {
      case 0:
      case 2:
         if (usePAR) {
            result = SetupPar(module);
            if (rec) anaPars += Form("%s.par ", module);
         } else {
            result = gSystem->Load(Form("lib%s.so", module));
            if (rec) anaLibs += Form("lib%s.so ", module);
         }   
         break;
      case 1:
         result = gProof->UploadPackage(module);
         if (result<0) {
            result = gProof->UploadPackage(gSystem->ExpandPathName(Form("$ALICE_ROOT/%s.par", module)));
            if (result<0) {
               ::Error("AnalysisTrainNew.C::LoadLibrary", "Could not find module %s.par in current directory nor in $ALICE_ROOT", module);
               return kFALSE;
            }
         }   
         result = gProof->EnablePackage(module);
         break;
      default:
         return kFALSE;
   }         
   if (result < 0) {
      ::Error("AnalysisTrainNew.C::LoadLibrary", "Could not load module %s", module);
      return kFALSE;
   }
   return kTRUE;
}           

//______________________________________________________________________________
TChain *CreateChain(const char *mode, const char *plugin_mode)
{
// Create the input chain
   Int_t imode = -1;
   if (!strcmp(mode, "LOCAL")) imode = 0;
   if (!strcmp(mode, "PROOF")) imode = 1;
   if (!strcmp(mode, "GRID"))  imode = 2;
   TChain *chain = NULL;
   // Local chain
   switch (imode) {
      case 0:
         if (iAODanalysis) {
            if (!local_xmldataset.Length()) {
               // Local AOD
               chain = new TChain("aodTree");
               if (gSystem->AccessPathName("data/AliAOD.root")) 
                  ::Error("AnalysisTrainNew.C::CreateChain", "File: AliAOD.root not in ./data dir");
               else {
                  if (!saveTrain) chain->Add("data/AliAOD.root");
                  else            chain->Add("../data/AliAOD.root");
               }   
            } else {
               // Interactive AOD
               chain = CreateChainSingle(local_xmldataset, "aodTree");
            }
         } else {      
            if (!local_xmldataset.Length()) {
               // Local ESD
               chain = new TChain("esdTree");
               if (gSystem->AccessPathName("data/AliESDs.root")) 
                  ::Error("AnalysisTrainNew.C::CreateChain", "File: AliESDs.root not in ./data dir");
               else {
                  if (!saveTrain) chain->Add("data/AliESDs.root");
                  else            chain->Add("../data/AliESDs.root");
               }   
            } else {
               // Interactive ESD
               chain = CreateChainSingle(local_xmldataset, "esdTree");
            }   
         }
         break;
      case 1:
         break;
      case 2:
         if (usePLUGIN) {
//            AliAnalysisGrid *alienHandler = CreateAlienHandler(plugin_mode);
//            AliAnalysisManager::GetAnalysisManager()->SetGridHandler(alienHandler);
         } else {
            TString           treeName = "esdTree";
            if (iAODanalysis) treeName = "aodTree";
            chain = CreateChainSingle("wn.xml", treeName);
         }
         break;      
      default:   
   }
   if (chain && chain->GetNtrees()) return chain;
   return NULL;
}   

//______________________________________________________________________________
TChain* CreateChainSingle(const char* xmlfile, const char *treeName)
{
   printf("*******************************\n");
   printf("*** Getting the ESD Chain   ***\n");
   printf("*******************************\n");
   TAlienCollection * myCollection  = TAlienCollection::Open(xmlfile);

   if (!myCollection) {
      ::Error("AnalysisTrainNew.C::CreateChainSingle", "Cannot create an AliEn collection from %s", xmlfile) ;
      return NULL ;
   }

   TChain* chain = new TChain(treeName);
   myCollection->Reset() ;
   while ( myCollection->Next() ) chain->Add(myCollection->GetTURL("")) ;
   chain->ls();
   return chain;
}

//______________________________________________________________________________
Int_t SetupPar(char* pararchivename)
{
   if (!pararchivename || !strlen(pararchivename)) return -1;
   char processline[1024];
   if (gSystem->AccessPathName(Form("%s.par", pararchivename))) {
      if (!gSystem->AccessPathName(Form("%s/%s.par", gSystem->Getenv("ALICE_ROOT"),pararchivename))) {
         ::Info("AnalysisTrainNew.C::SetupPar", "Getting %s.par from $ALICE_ROOT", pararchivename);
         TFile::Cp(gSystem->ExpandPathName(Form("$ALICE_ROOT/%s.par", pararchivename)), 
                   Form("%s.par",pararchivename));
      } else {
         ::Error("AnalysisTrainNew.C::SetupPar", "Cannot find %s.par", pararchivename);
         return -1;
      }   
   }
   if (usePLUGIN && saveTrain) gSystem->Exec(Form("ln -s ../%s.par %s",pararchivename, train_name.Data()));
   gSystem->Exec(Form("tar xvzf %s.par", pararchivename));

   TString ocwd = gSystem->WorkingDirectory();
   if (!gSystem->ChangeDirectory(pararchivename)) return -1;
	
   // check for BUILD.sh and execute
   if (!gSystem->AccessPathName("PROOF-INF/BUILD.sh")) {
      printf("*******************************\n");
      printf("*** Building PAR archive    ***\n");
      printf("*******************************\n");	    
      if (gSystem->Exec("PROOF-INF/BUILD.sh")) {
         Error("runProcess","Cannot Build the PAR Archive! - Abort!");
         return -1;
      }
   }

	// check for SETUP.C and execute
	if (!gSystem->AccessPathName("PROOF-INF/SETUP.C")) {
	    printf("*******************************\n");
	    printf("*** Setup PAR archive       ***\n");
	    printf("*******************************\n");
	    gROOT->Macro("PROOF-INF/SETUP.C");
	}	
	if (!gSystem->ChangeDirectory(ocwd.Data())) return -1;
   return 0;
}

//______________________________________________________________________________
AliAnalysisAlien* CreateAlienHandler(const char *plugin_mode)
{
// Check if user has a valid token, otherwise make one. This has limitations.
// One can always follow the standard procedure of calling alien-token-init then
   AliAnalysisAlien *plugin = new AliAnalysisAlien();
// Set the run mode (can be "full", "test", "offline", "submit" or "terminate")
   plugin->SetRunMode(plugin_mode);
   if (useProductionMode) {
      plugin->SetProductionMode();
      plugin->AddDataFile(data_collection);
   }   
      
   if (!outputSingleFolder.IsNull()) {
      plugin->SetOutputSingleFolder(outputSingleFolder);
      plugin->SetOutputToRunNo();
   }   
   plugin->SetJobTag(job_tag);
   plugin->SetNtestFiles(nTestFiles);
   plugin->SetCheckCopy(kFALSE);
   plugin->SetMergeDirName(mergeDirName);
// Set versions of used packages
   //***plugin->SetAPIVersion("V1.1x");
   //***plugin->SetROOTVersion(root_version);
   //***plugin->SetAliROOTVersion(aliroot_version);
   plugin->SetAliPhysicsVersion(aliphysics_version);
// Declare input data to be processed.
// Method 1: Create automatically XML collections using alien 'find' command.
// Define production directory LFN
   plugin->SetGridDataDir(alien_datadir);
// Set data search pattern
   plugin->SetDataPattern(data_pattern);
   if (!useProductionMode) {
      if (runOnData) {
         plugin->SetRunPrefix("000");
      }   
//   if (!iAODanalysis) plugin->SetRunRange(run_range[0], run_range[1]);
      for (Int_t i=0; i<10; i++) {
         if (run_numbers[i]==0) break;
         plugin->AddRunNumber(run_numbers[i]);
      }   
   }   
// Define alien work directory where all files will be copied. Relative to alien $HOME.
   plugin->SetGridWorkingDir(grid_workdir);
// Declare alien output directory. Relative to working directory.
   if (alien_outdir.IsNull()) alien_outdir = Form("output_%s",train_name.Data());
   plugin->SetGridOutputDir(alien_outdir);

   TString ana_sources = "";
   TString ana_add = "";
   if (usePAR && anaPars.Length()) {
      printf("%s\n", anaPars.Data());
      TObjArray *arr;
      TObjString *objstr;
      arr = anaPars.Tokenize(" ");
      TIter next(arr);
      while ((objstr=(TObjString*)next())) plugin->EnablePackage(objstr->GetString());
      delete arr;
   } 
// Add external packages
   if (iJETAN || iJETANdelta) {
      plugin->AddExternalPackage("boost::v1_43_0");
      plugin->AddExternalPackage("cgal::v3.6");
      plugin->AddExternalPackage("fastjet::v2.4.2");
   }   
   
// Declare the analysis source files names separated by blancs. To be compiled runtime
// using ACLiC on the worker nodes.
   ana_sources = ana_sources.Strip();
// Declare all libraries (other than the default ones for the framework. These will be
// loaded by the generated analysis macro. Add all extra files (task .cxx/.h) here.
   anaLibs     = anaLibs.Strip();   
   if (ana_sources.Length()) plugin->SetAnalysisSource(ana_sources);
   if (anaLibs.Length())     plugin->SetAdditionalLibs(anaLibs);
     
// Declare the output file names separated by blancs.
// (can be like: file.root or file.root@ALICE::Niham::File)
   plugin->SetDefaultOutputs();
   plugin->SetMergeExcludes(mergeExclude);
   plugin->SetMaxMergeFiles(maxMergeFiles);
   plugin->SetNrunsPerMaster(nRunsPerMaster);
// Optionally define the files to be archived.
//   plugin->SetOutputArchive("log_archive.zip:stdout,stderr@ALICE::NIHAM::File root_archive.zip:AliAOD.root,AOD.tag.root@ALICE::NIHAM::File");
   
   
   // Put default output files to archive
   TString listhists = "";
   TString listaods  = "";
   AliAnalysisManager *mgr = AliAnalysisManager::GetAnalysisManager();
   TIter next(mgr->GetOutputs());
   AliAnalysisDataContainer *output;
   while ((output=(AliAnalysisDataContainer*)next())) {
      const char *filename = output->GetFileName();
      if (!(strcmp(filename, "default"))) {
         if (!mgr->GetOutputEventHandler()) continue;
         filename = mgr->GetOutputEventHandler()->GetOutputFileName();
         if (listaods.Length()) listaods += ",";
         listaods += filename;
         listaods += ",";
         listaods += "pyxsec_hists.root";
      } else {
         if (!strcmp(filename, "pyxsec_hists.root")) continue;
         if (listhists.Contains(filename)) continue;
         if (listhists.Length()) listhists += ",";
         listhists += filename;
      }
   }
   if (mgr->GetExtraFiles().Length()) {
      if (listaods.Length()) listaods += ",";
      listaods += mgr->GetExtraFiles();
      listaods.ReplaceAll(" ", ",");
   }
   if (listhists.Length()) listhists = Form("hist_archive.zip:%s@%s", listhists.Data(), outputStorages.Data());
   if (listaods.Length())  listaods  = Form("aod_archive.zip:%s@%s", listaods.Data(), outputStorages.Data());
   if (!listhists.Length() && !listaods.Length()) {
      ::Fatal("AnalysisTrainNew", "No task output !");
   }
   TString outputArchive = Form("log_archive.zip:stderr@%s", outputStorages.Data());
   if (listaods.Length()) {
      outputArchive += " ";
      outputArchive += listaods;
   }   
   if (listhists.Length()) {
      outputArchive += " ";
      outputArchive += listhists;
   }   
   
// Set friends
//   if (iAODanalysis && iPWG3d2h) 
//      plugin->SetFriendChainName("AliAOD.VertexingHF.root");
//   plugin->SetOutputArchive(outputArchive);
// Optionally set a name for the generated analysis macro (default MyAnalysis.C)
   plugin->SetAnalysisMacro(Form("%s.C", train_name.Data()));
// Optionally set a name for the generated validation script
   plugin->SetValidationScript("FILTERvalidation.sh");
// Optionally set maximum number of input files/subjob (default 100, put 0 to ignore)
   plugin->SetSplitMaxInputFileNumber(nFilesPerJob);
// Optionally set number of failed jobs that will trigger killing waiting sub-jobs.
//   plugin->SetMaxInitFailed(5);
// Optionally modify the number of replicas
   plugin->SetNumberOfReplicas(outputReplicas);
// Optionally resubmit threshold.
//   plugin->SetMasterResubmitThreshold(90);
// Optionally set time to live (default 30000 sec)
   plugin->SetTTL(70000);
// Optionally set input format (default xml-single)
   plugin->SetInputFormat("xml-single");
// Optionally modify the name of the generated JDL (default analysis.jdl)
   plugin->SetJDLName(Form("%s.jdl", train_name.Data()));
// Optionally modify the executable name (default analysis.sh)
   plugin->SetExecutable(Form("%s.sh", train_name.Data()));
// Optionally modify job price (default 1)
   plugin->SetPrice(1);      
// Merge via JDL
   plugin->SetMergeViaJDL(useMergeViaJDL);
// Use fastread option
   plugin->SetFastReadOption(useFastReadOption);
// UseOverwrite mode
   plugin->SetOverwriteMode(useOverwriteMode);   
   plugin->SetExecutableCommand("aliroot -b -q");
// Optionally modify split mode (default 'se')    
   plugin->SetSplitMode("se");
   plugin->SetNumberOfReplicas(outputReplicas);
   return plugin;
}

//______________________________________________________________________________
void WriteConfig()
{
// Write train configuration in a file. The file name has the format:
// train_[trainName]_ddMonthyyyy_time.C
   if (useDATE) {
      gSystem->Exec("date +%d%b%Y_%Hh%M > date.tmp");
      ifstream fdate("date.tmp");
      if (!fdate.is_open()) {
         ::Error("AnalysisTrainNew.C::Export","Could not generate file name");
         return;
      }
      const char date[64];
      fdate.getline(date,64);
      fdate.close();
      gSystem->Exec("rm date.tmp");
      train_name = Form("%s_%s", train_name.Data(), date);
   }   
   TString cdir = gSystem->WorkingDirectory();
   gSystem->MakeDirectory(train_name);
   gSystem->ChangeDirectory(train_name);
   ofstream out;
   out.open(Form("%sConfig.C",train_name.Data()), ios::out); 
   if (out.bad()) {
      ::Error("AnalysisTrainNew.C::Export", "Cannot open ConfigTrain.C for writing");
      return;
   }
   out << "{" << endl;
   out << "   train_name      = " << "\"" << train_name.Data() << "\";" << endl;
   out << "   proof_cluster   = " << "\"" << proof_cluster.Data() << "\";" << endl;
   out << "   useAFPAR        = " << useAFPAR << ";" << endl;
   if (useAFPAR) 
      out << "   AFversion       = " << AFversion.Data() << ";" << endl;
   out << "   proof_dataset   = " << "\"" << proof_dataset.Data() << "\";" << endl;
   out << "   usePLUGIN       = " << usePLUGIN << ";" << endl;
   out << "   usePAR          = " << usePAR << ";" << endl;
   out << "   useCPAR         = " << useCPAR << ";" << endl;
   //out << "   root_version    = " << "\"" << root_version.Data() << "\";" << endl;
   //out << "   aliroot_version = " << "\"" << aliroot_version.Data() << "\";" << endl;
   out << "   alien_datadir   = " << "\"" << alien_datadir.Data() << "\";" << endl;
   if (!alien_outdir.Length()) alien_outdir = Form("output_%s",train_name.Data());
   out << "   alien_outdir    = " << "\"" << alien_outdir.Data() << "\";" << endl;
   out << "   maxMergeFiles   = " << maxMergeFiles << ";" << endl;
   out << "   mergeExclude    = " << "\"" << mergeExclude.Data() << "\";" << endl;
   out << "   nRunsPerMaster  = " << nRunsPerMaster << ";" << endl;
   out << "   nFilesPerJob    = " << nFilesPerJob << ";" << endl;
//   for (Int_t i=0; i<10; i++) {
//      if (run_numbers[i]) 
//         out << "   run_numbers[" << i << "]  = " << run_numbers[i] << ";" << endl;
//   }
//   out << "   run_range[0]    = " << run_range[0] << ";" << endl;
//   out << "   run_range[1]    = " << run_range[1] << ";" << endl;
   out << "   usePhysicsSelection = " << usePhysicsSelection << ";" << endl;
   out << "   useTender       = " << useTender << ";" << endl;
   out << "   useMergeViaJDL  = " << useMergeViaJDL << ";" << endl;
   out << "   useOverwriteMode  = " << useOverwriteMode << ";" << endl;
   out << "   useFastReadOption = " << useFastReadOption << ";" << endl;
   out << "   useDBG          = " << useDBG << ";" << endl;
   out << "   useMC           = " << useMC << ";" << endl;
   out << "   useTAGS         = " << useTAGS << ";" << endl;
   out << "   useKFILTER      = " << useKFILTER << ";" << endl;
   out << "   useTR           = " << useTR << ";" << endl;
   out << "   useCORRFW       = " << useCORRFW << ";" << endl;
   out << "   useAODTAGS      = " << useAODTAGS << ";" << endl;
   out << "   saveTrain       = " << "kFALSE;" << endl << endl;
   out << "   // Analysis modules" << endl;
   out << "   iAODanalysis    = " << iAODanalysis << ";" << endl;
   out << "   iAODhandler     = " << iAODhandler << ";" << endl;
   out << "   iESDfilter      = " << iESDfilter << ";" << endl;
   out << "   iMUONcopyAOD    = " << iMUONcopyAOD << ";" << endl;
   out << "   iJETAN          = " << iJETAN << ";" << endl;
   out << "   iJETANdelta     = " << iJETANdelta << ";" << endl;
   out << "   iPWG4partcorr   = " << iPWG4partcorr << ";" << endl;
   out << "   iPWGGAgammaconv  = " << iPWGGAgammaconv << ";" << endl;
   out << "   iPWG4omega3pi   = " << iPWG4omega3pi << ";" << endl;
   out << "   iPWGHFvertexing  = " << iPWGHFvertexing << ";" << endl;   
   out << "   iPWG3hfe        = " << iPWG3hfe << ";" << endl;   
   out << "   iPWGDQJPSIfilter = " << iPWGDQJPSIfilter << ";" << endl;   
   out << "   iPWGDQJPSI       = " << iPWGDQJPSI << ";" << endl;   
   out << "   iPWGHFd2h        = " << iPWGHFd2h << ";" << endl;   
   out << "   iPWGMuonTrain      = " << iPWGMuonTrain << ";" << endl;   
   out << "   iPWG2femto      = " << iPWG2femto << ";" << endl;
   out << "   iPWG2spectra    = " << iPWG2spectra << ";" << endl;
   out << "     iPWG2protons      = " << iPWG2protons << ";" << endl;
   out << "     iPWG2checkcascade = " << iPWG2checkcascade << ";" << endl;
   out << "     iPWG2perfcascade  = " << iPWG2perfcascade << ";" << endl;
   out << "     iPWG2checkv0      = " << iPWG2checkv0 << ";" << endl;
   out << "     iPWG2strange      = " << iPWG2strange << ";" << endl;
   out << "     iPWG2central      = " << iPWG2central << ";" << endl;
   out << "   iPWG2flow       = " << iPWG2flow << ";" << endl;
   out << "   iPWG2res        = " << iPWG2res << ";" << endl;
   out << "     iPWG2rsneff   = " << iPWG2rsneff << ";" << endl;
   out << "   iPWG2kink       = " << iPWG2kink << ";" << endl;
   out << "     iPWG2kinkESDMC    = " << iPWG2kinkESDMC << ";" << endl;
   out << "     iPWG2kinkLSKstar  = " << iPWG2kinkLSKstar << ";" << endl;
   out << "     iPWG2kinkLSL1520  = " << iPWG2kinkLSL1520 << ";" << endl;
   out << "     iPWG2kinkLSPhi    = " << iPWG2kinkLSPhi << ";" << endl;
   out << "     iPWG2kinkKstarESD = " << iPWG2kinkKstarESD << ";" << endl;
   out << "     iPWG2kinkKstarMC  = " << iPWG2kinkKstarMC << ";" << endl;
   out << "     iPWG2kinkL1520ESD = " << iPWG2kinkL1520ESD << ";" << endl;
   out << "     iPWG2kinkL1520MC  = " << iPWG2kinkL1520MC << ";" << endl;
   out << "     iPWG2kinkPhiESD   = " << iPWG2kinkPhiESD << ";" << endl;
   out << "     iPWG2kinkPhiMC    = " << iPWG2kinkPhiMC << ";" << endl;
   out << "   iPWG2unicor     = " << iPWG2unicor << ";" << endl;
   out << "   iPWG2evchar     = " << iPWG2evchar << ";" << endl;
   out << "   iPWGLFForward    = " << iPWGLFForward << ";" << endl << endl;
   out << "// Configuration fot the wagons" << endl;
   out << "   configPWG2femto = \"" << configPWG2femto << "\";" << endl;
   //out << "   configPWG3d2h   = \"" << configPWG3d2h << "\";" << endl;
   out << "}" << endl;
   ::Info("AnalysisTrainNew.C::WriteConfig", "Train configuration wrote to file %s", Form("config_%s.C", train_name.Data()));
   gSystem->ChangeDirectory(cdir);
}   

//______________________________________________________________________________
Bool_t LoadConfig(const char *filename)
{
// Read train configuration from file
   if (gSystem->AccessPathName(filename)) {
      ::Error("AnalysisTrainNew.C::LoadConfig", "Config file name not found");
      return kFALSE;
   }   
   gROOT->ProcessLine(Form(".x %s", filename));
   ::Info("AnalysisTrainNew.C::LoadConfig", "Train configuration loaded from file %s", filename);
   return kTRUE;
}

//______________________________________________________________________________
void ProcessEnvironment()
{
  //
  // Collision system configuration
  //
  if(gSystem->Getenv("ALIEN_JDL_LPMINTERACTIONTYPE"))
  {
    for (Int_t icoll = 0; icoll < kNSystem; icoll++)
      if (strcmp(gSystem->Getenv("ALIEN_JDL_LPMINTERACTIONTYPE"), CollisionSystem[icoll]) == 0) 
      {
        iCollision = icoll;

        if(icoll == kpA)
            iCollision =kpp;
      }

      if(iCollision == kPbPb)
      {
        useCentrality =kTRUE;
        train_tag = "_Pb-Pb_";
      }
      else
        train_tag = "_p-p_";
  }
  else
    if(!localRunning)
    {
      printf(">>>>> Unknown collision system configuration ALIEN_JDL_LPMINTERACTIONTYPE \n");
      abort();
    }

  //
  // Setting the period
  //
  if(gSystem->Getenv("ALIEN_JDL_LPMPRODUCTIONTAG"))
    periodName = gSystem->Getenv("ALIEN_JDL_LPMPRODUCTIONTAG");
  else
    if(!localRunning)
    {
      printf(">>>>> Unknown production tag configuration ALIEN_JDL_LPMPRODUCTIONTAG \n");
      abort();
    }
    
  //
  // Run flag configuration
  //
  if(gSystem->Getenv("ALIEN_JDL_LPMANCHORYEAR"))
  {
    Int_t year = atoi(gSystem->Getenv("ALIEN_JDL_LPMANCHORYEAR"));

    if(year<2015)
      run_flag =1100;
    else
      run_flag =1500;
    if(year<=2010) 
    {
      run_flag =1000;
      if(periodName.EqualTo("LHC10h"))
        run_flag = 1001;
    }
  }
  else
    if(!localRunning)
    {
      printf(">>>>> Unknown anchor year system configuration ALIEN_JDL_LPMANCHORYEAR \n");
      abort();
    }

  //
  // Run number
  //
  if (gSystem->Getenv("ALIEN_JDL_LPMRUNNUMBER"))
    run_number = atoi(gSystem->Getenv("ALIEN_JDL_LPMRUNNUMBER"));
  else
    if(!localRunning)
    {
      printf(">>>>> Unknown run number ALIEN_JDL_LPMRUNNUMBER \n");
      abort();
    }
  if (run_number <= 0)
    printf(">>>>> Invalid run number: %d \n", run_number);

  //
  // Setting this to kTRUE will disable some not needed analysis tasks for a muon_calo pass
  //
  if (gSystem->Getenv("ALIEN_JDL_RAWPRODTYPE"))
  {
    TString passType = gSystem->Getenv("ALIEN_JDL_RAWPRODTYPE");
    if (passType.Contains("muon_calo"))
      isMuonCaloPass = kTRUE;
    else
      isMuonCaloPass = kFALSE;
  }
  else
    if(!localRunning)
    {
      printf(">>>>> Unknown production type ALIEN_JDL_RAWPRODTYPE \n");
      abort();
    }
}

//________________________________________________________
void PrintSettings()
{
  printf("\n   **********************************\n");
  printf("   * \n");
  printf("   * System:         %s\n", CollisionSystem[iCollision]);
  printf("   * Period name:    %s\n", periodName.Data());
  printf("   * Run number:     %d\n", run_number);
  printf("   * Run flag:       %d\n", run_flag);
  printf("   * Muon calo pass: %d\n", isMuonCaloPass);
  printf("   * Centrality:     %d\n", useCentrality);
  printf("   * \n");
  printf("   **********************************\n\n");
}
